### [剑指 Offer 43. 1～n 整数中 1 出现的次数](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。

 
**示例 1：**

> 输入：n = 13
输出：6

**示例 2：**

> 输入：n = 0
输出：0
 


参考题解：[面试题43. 1～n 整数中 1 出现的次数（清晰图解）](https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/)

举个例子： `n = 2304` 。答案为四个部分之和：

1. 所有小于等于2304的正整数中，个位出现1的次数.
2. 所有小于等于2304的正整数中，十位出现1的次数.
3. 所有小于等于2304的正整数中，百位出现1的次数.
4. 所有小于等于2304的正整数中，千位出现1的次数.

这四部分可以只考虑一部分，另外三部分就异曲同工了。用第二部分来举例，也就是计算所有小于等于2304的正整数中，十位出现1的次数：

为了帮助理解，我们先想象有一个自行车密码锁（这个比喻来自@ryan0414），一共有四位，每一位可单独滚动。为了计算十位出现1的次数，我们考虑三种情况：

`1. n中的十位为0. 即 n = 2304。`
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：`2219`,

我们能滚出的最小数是：`0010`。

那么0010到2219之间有多少种十位为1的密码呢？我们去掉十位，得到000和229。一共就是229-000+1 = 230种。即`n千位和百位构成的数*10。`

`2. n中的十位为1. 即 n = 2314。`
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：`2314`,

我们能滚出的最小数是：`0010`。

那么0010到2314之间有多少种十位为1的密码呢？我们去掉十位，得到000和234，一共就是23*10+4+1 = 235种。即`n千位和百位构成的数*10 + n个位的数字+1.`

`3. n中的十位为2~9中任意数字. 即 n = 2324（只是一个例子，n = 2394是一样的）。`
我们先锁住十位，强行让十位变成1，剩下三位可以随意滚动：XX1X。那么求十位出现一的个数也就是，我可以滚出多少种密码组合，使得该密码小于等于n（注意十位被锁定成了1，转不动）。

不难发现，我们能滚出的最大数是：`2319`,

我们能滚出的最小数是：`0010`。

那么0010到2319之间有多少种十位为1的密码呢？我们去掉十位，得到000和239，一共就是239-000+1 = 240种。也是（23+1）*10 = 240种。即`(n千位和百位构成的数+1)*10.`

如果我们定义十位左边的数为高位，例如2304的高位为23，十位右边的数为低位，例如2304的低位为4，那么以上规律就可以写成高位和低位的规律。我们分别对2304的每一位做一次分析，并将四部分结果相加就得到了答案.



```java
class Solution {
    public int countDigitOne(int n) {
        int res = 0;
        int high = n / 10, cur = n % 10, low = 0;
        int digit = 1;
        while (high != 0 || cur != 0){
            if (cur == 0){
                res += high * digit;
            }
            else if (cur == 1){
                res += high * digit + low + 1;
            }
            else {
                res += (high + 1) * digit;
            }
            //递推
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }
}
```
